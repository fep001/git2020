# 系统I/O  

## linux
- cd命令
    - 绝对路径,从根开始,由父及子: cd /
    - 相对路径,从当前开始,'.'一点为本级,''..''向上一级:cd ../
- ls 显示文件列表
- cp 复制  
- mv 移动  
- rm 删除  
- mkdir 创建文件夹  
- touch 创建文件  
- cat 查看文件

## 文件  
- 文件是保存在持久化存储设备上的一段数据  
    - 按格式编码分:  
        - 文本文件,打开后会自动解码为字符,均可转为二进制文件  
        - 二进制文件,音频视频,python中引用了字节串bytes用字节序列值来存储
    - python转码  
        - ascii码转bytes,使用b'ascii'格式  
        - str转bytes,使用str.encode()
        - bytes转str,使用bytes.decode(),需支持utf-8的才可转  
    - 对文件的操作  
        - 对文件可以打开,读写,关闭  
        - 打开文件:  
            - file_object = open(file_name,access_mode="r",buffering=-1)  
            - 功能:打开一个文件
            - 参数:file_name,以字符串方式传入文件名可以含有文件路径  
            - access_mode::=("r"|"w"|"a"|"r+"|"w+"|"a+"|"rb"|"wb"|"ab"|"rb+"|"wb+"|"ab+") ,r对已存在只读,w只写,a追加不清空,+读写,b二进制  文本可以用二进制传入二进制写
            - buffering:缓存模式 1表示有行缓存,刷新内存缓冲区条件(缓冲区被写满|文件对象被关闭|程序执行结束|程序调用file.flush()|行缓冲遇到换行)
            - 返回:一个文件对象
        - 读取内容:
            - read([size=-1]) 功能:直接读取对象中字符  
            参数:size表示从开始总的最多读取的字符,可循环向后读,默认为到对象最后 返回:返回到读取的内容  注意:文件较大不建议一次读完,找开方式,可设检效到空串跳出,
            - readline([size=-1]) 功能:读取文件中的一行 参数:size表示每行最大读取的字符(字节) 返回:读取到的内容 注意:到未尾要设检效   
            - readlines() 功能:读取文件中的每一行作为列表中的一项  参数:size表示总的最大读取的字符(字节)所在的行数(全行返回) 返回:将文件内容保存到列表  
            - for line in file_object,功能:因文件对象是可迭代对象,故可用for获得行数据  返回:用line保留行内容
        - 写入文件:  
            - write(string) 功能:把文本数据或二进制数据块的字符串写入到文件中去;参数:要写的入内容,可加\n换行;返回值:写入的字符个数  
            - writelines(str_list)  功能:接受一个字符串列表作为参数将它们写文件,换行仍需加换行符\n  
        - 文件偏移量  
            - 是打开一个文件对象进行操作的位置记录,默认是自动记录,open文件对象会重置,读写使用同一偏移量记录,以r和w打开基准位置在文件头,以a打开基准位置在文件尾  
            - tell(),功能:显示一个对象的当前偏移位置  
            - seek(offset[,whence]);功能:移动文件偏移量位置,一般以二进制方式打开;参数:offset相对于某位置的字节数,负倒车,正向前;whence表示基准位置(0默认文件头|1当前|2文件尾)除位置为文件头外需以二进制打开
        - 关闭文件
            - file_object.close()
        - with语句  
            - with context_expression <open(file_name,mode)> [as obj]:
                - with_body  
            - 通过with生成的对象在词句块结束后会自动close() obj对象
        - 占位文件  
            - 可以通过seek(1024*1024*n,2);file_object.write(b" ")生成占用N兆的文件  
    - 文件描述符  
        - 对每一个IO操作分配的整数编号  
        - 通过fileno()获取  
    - 文件函数  
        - os.path.getsize(file) ->文件大小  
        - os.listdir(dir) ->目录下文件列表(./当前|../上级)  
        - os.path.exists(file) ->文件存在吗  
        - os.path.isfile(file) ->是文件吗,非目录  
        - os.remove(file) ->删除文件
        
## 网络基础  
- 由iso制定的osi七层模型  
    - 应用层:提供用户服务,具体功能有应用程序实现  
    - 表示层:数据的压缩优化加密  
    - 会话层:建立用户级的连接,选择适当的传输服务  
    - 传输层:提供传输服务  
    - 网络层:路由选择,网络互联  
    - 链路层:进行数据交换,控制具体数据的发送
    - 物理层:提供数据传输的硬件保证,网卡接口,传输介质  
- TCP|IP四层模型  
    - 应用层
    - 传输层  
    - 网际层  
    - 物理层   
- 数据传输  
    - 发送前通过逐层在首部添加协议  
- 网络基础概念  
    - IP地址:一台主机的网络路由位置,用ifconfig查看本机,IPV4用三个点分十进制表示<127.0.0.1>->本机测试,每部分值域0-255(8*4),IPV6为128位   
    - 域名:给网络服务器地址起的名字  
    - ping[ip]:测试和某个主机是否联通  
    - 端口号(port):是网址的一部分,用于区分主机上不同的网络应用程序;一个系统中的应用监听端口不能重复;取值为1-65535(其中:1-1013为系统应用或大众程序监听端口)  
- 传输层  
    - 面对连接的传输服务(基于TCP协议的数据传输)  
        - 可靠的数据传输(无丢失|无失序|无差错|无重复) 
        - 实现手段:  
            - 通信前建立数据连接  
            - 通信时有响应回复  
            - 通信结束要正常断开连接  
        - TCP的三次握手(建立连接,客户端->服务器)  
            - client-(发送报文,请求连接<syn=1,seq=x>)->server  
            - server-(收到请求)-(回复报文,确定可连接<syn=1,ack=x+1,seq=y>)->client  
            - client-(收到回复)-(发送最终报文<ack=y+1,seq=z>)->server:连接建立
        - TCP的四次挥手(断开连接,主动方->被动方)  
            - active-(发送报文,请求断开<fin=1,ack=2,seq=x>)->passive  
            - passive-(收到请求)-(立即回复,做断开准备<ack=x+1,seq=z>)->active  
            - passive-(准备就绪)-(再次发送报文,表示可断开<fin=1,ack=x,seq=y>)->active  
            - active-(收到确定)-(发送最终报文,完成断开<ack=y,seq=x>)  
    - 面向无连接的传输服务(基于UDP协议的数据传输)  
        - 特点:  
            - 不保证传输的可靠性  
            - 传输过程没有连接和断开  
            - 数据收发自由随意  
        - 适用:  
            - 网络较差,对传输可靠性要求不高  
            - 如网络视频,群聊,广播   
- socket(插头)套接字  
    - 实现网络编程进行数据传输的一种技术手段  
    - 模块:import socket  
    - 分类:  
        - 流式套接字(sock_stream),以字节流方式传输数据,实现TCP网络传输方案  
        - 数据套接字(sock_dgram),以数据报形式传输数据,实现UDP网络传输方案  
    - 服务端 I/O  
        - 流程:socket->bind绑定->listen->accept接受->(send发送|recv接收)->close  
        - sockfd = socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=0)  
            - 功能:创建套接字  
            - 返回:套接字对象  
            - 参数:socket_family网址类型(AF_INET表示IPV4|AF_INET6表示IPV6);socket_type套接字类型(SOCK_STREAM流式|SOCK_DGRAM数据);proto通常为0,选择子协议
        - sockfd.bind(addr)  
            - 功能:绑定本机网络地址  
            - 返回:  
            - 参数:addr是(ip,port)的二元元组<"0.0.0.0",8888>,ip为("localhost"|"127.0.0.1")是本地测试地址只能被主机访问,ip为外网地址本地和外网均可以用此访问,ip为"0.0.0.0"是开放全部权限本地可以(外网地址|"127.0.0.1")外网可以用外网地址访问  
        - sockfd.listen(n)  
            - 功能:将套接字设置为监听套接字,确定监听队列  
            - 返回:  
            - 参数:n监听队列大小  
        - connfd,addr = sockfd.accept()  
            - 功能:阻塞等待处理客户端请求  
            - 返回:connfd客户端连接套接字;addr连接的客户端地址  
        - data = connfd.recv(buffersize)  
            - 功能:接收客户的消息,类似文件的读  
            - 返回:接收到的内容  
            - 参数:buffersize每次最大接收消息的大小  
        - n = connfd.send(data)  
            - 功能:发送消息,类似文件的写  
            - 返回值:发送的字节数  
            - 参数:要发送的内容 bytes格式  
    - 客户端 I/O  
        - sockfd = socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=0)
            - 参数选择与服务端一致  
        - sockfd.connect((server_addr)) 
            - 功能:连接服务器  
            - 参数:服务器(ip,port)元组
            - 对应服务器的sockfd.accept()->服务器会获取(connfd,addr),并以connfd为传输数据的套接字对象
        - sockfd.send(data)  
        - sockfd.recv(buffersize)->为阻塞函数  
        - sockfd.close()  
    - 套接字特点  
        - tcp 连接中当一端退出,另一端如果阻塞在recv(),此时recv会立即返回一个空字串 可用判断空字串跳出循环接收    
        - tcp 连接中如果一端已经不存在,仍然试图通过send发送,则会产生BrokenPipeError  
        - 一个监听套接字可以同时连接多个客户端,也能够重复被连接  
    - 网络收发缓冲区  
        - 网络缓冲区有效的协调了消息的收发速度  
        - send和recv实际是在向缓冲区发送接收消息,当缓冲区不为空,recv就不会阻塞  
    - tcp粘包  
        - 原因:tcp以字节流方式传输,没有消息边界,多次发送的消息被一次接  
        - 影响:如每次内容是一个独立的含义会影响接收端解析  
        - 消除:人为添加消息边界,控制发送速度  
- UDP套接字
    - 服务端 I/O  
        - socket_server = socket.socket(AF_INET,SOCK_DGRAM)
            - 功能:实例化UDP套接字
            - 参数:socket_family=AF_INET,socket_type=SOCK_DGRAM
            - 返回:生成DGRAM实例fd
        - socket_server.bind(addr_tupe<ip,port>)
            - 功能:绑定实例laddr属性为addr  
            - 参数:addr_tupe
        - data,addr = socket_server.recvform(buffersize)
            - 功能:接收UDP消息  
            - 参数:每次接收多少字节,每次多于此的会丢包  
            - 返回值:data接收到的bytes内容,addr消息来源的地址  
        - n = socket_server.sendto(data,addr)
            - 功能:发送UDP消息  
            - 参数:data发送的bytes内容,addr消息发送目标的地址    
            - 返回值:发送了多少字节 
        - socket_server.close()
    - 客户端 I/O 参数与服务端对应    
        - socket_client = socket.socket(AF_INET,SOCK_DGRAM) 
        - n = socket_client.sendto(data,addr<server_ip,server_port>)
        - data,server_addr = socket_client.recvform(buffersize)  
        - socket_client.close()
- 流式套接字(使用tcp传输协议)与udp(使用udp传输协议)比较  
    - 数据传输方式  
        - tcp使用字节流  
        - udp使用数据报  
    - 粘包  
        - tcp连续接收会出现粘包  
        - udp有消息边界不会出现粘包  
    - 数据完整性  
        - tcp保证消息的完整性  
        - udp不保证消息的完整性,按次使用buffersize接收,超过则丢失  
    - 传输连接  
        - tcp依赖listen,accept建立连接后才能收发消息  
        - udp无需先连接,直接连address收发消息  
    - 收发方法  
        - tcp使用send(data)->n发,recv(buffersize)->data收  
        - udp使用sendto(data,address_tuple)->n发,recvfrom(buffersize)->date,addr收
- socket套接字实例<socketfd>属性  
    - type 套接字类型SOCK_DGRAM  
    - family 地址类型AF_INET  
    - getsockname() ->获取绑定地址bind<ip,port>  
    - fileno() ->获取套接字的文件描述符  
    - getpeername() ->获取套接字的客户端地址(需使用客户端返回的connfd调用)  
    - setsockopt(level,option,value) func:设置套接字选项,arg:level类别sol_socket,option子类,value设置  
- struct模板用于bytes转换  
    - 原理:将一组简单数据进行打包转换为bytes格式发送,或将一组bytes格式数据进行解析,也可用于与其他程序的数据交互<使用网络字节区C语言为标准>    
    - st = struct.Struct(fmt) 功能:生成结构化对象;参数:fmt定制的数据结构"isf",i对应int,ns对应n*bytes超n会截尾还需注意UTF-8中汉字占三个字节,f对应float  
    - st.pack(arg1,...,argn)->bytes  功能:将数据arg按fmt格式进行打包;返回:bytes字节串  
    - st.unpack(bytes)->data 功能:将bytes字节串按指定fmt格式解析;参数:已用pack打包的bytes字节串;返回:按指定格式打包的内容  
    - 不预设fmt直接调用:struct.pack(fmt,arg1...argn);struct.unpack(fmt,bytes)  
- http超文本传输协议  
    - 用途:网页获取,数据的传输  
    - 特点:  
        - 应用层协议,传输层使用tcp传输  
        - 简单,灵活,很多语言都有HTTP专门接口  
        - 无状态,协议不记录传输内容  
        - HTTP1.1支持持久连接,丰富了请示类型  
- 网页请求过程  
    - client-http请求<tcp>->server  
    - server解析http请求  
    - server处理请求,组织响应内容  
    - server将响应内容以http响应格式->client  
    - client解析响应内容并展示  
- http请求  
    - 请求结构:请求行-请求头-空行-请求体  
    - 请求行:用空格分开的具体的<请求类别 请求内容 协议版本>  
        - 请求类别  
            - GET:获取网络资源(如点击网页,地址栏回车)  
            - POST:提交一定信息得到反馈(如注册)  
            - HEAD:只获取网络资源的响应头(如目录) 
            - PUT:更新服务器资源(百度网盘)  
            - DELETE:删除服务器资源  
            - CONNECT:
            - TRACE:测试  
            - OPTIONS:获取服务器性能信息
        - 请求内容:/表示主页根  
        - 协议版本 HTTP/1.1  
    - 请求头:对请求的进一步解释和描述  
        - 一行键值对 <Accept-Encoding:gzip>  
    - 空行:格式上的分离<\r\n>  
    - 请求体:请求参数或提交内容  
- http响应response  
    - 响应格式:响应行-响应头-空行-响应体  
    - 响应行:用空格分开的 (协议版本 响应码 附加信息)<http/1.1 200 ok> 
    - 响应码:  
        - 1XX 提示信息,表示请求被接收  
        - 2XX 响应成功  
            - 200 成功
        - 3XX 响应需进一步操作,重定向  
        - 4XX 客户端错误  
            - 400 服务器不理解请求的语法
            - 401 请求要求身份验证
            - 403 服务器禁止了你的请求
            - 404 服务器找不到请求的网页  
        - 5XX 服务器错误  
            - 500 服务器发生错误无法完成请求  
            - 502 错误的网关  
            - 505 http版本不支持  
    - 响应头  
        - 对响应内容的描述  
        - 一行键值对 <Content-Type:text/html>  
    - 空行:格式上的分离<\r\n>  
    - 响应体:响应的主体内容信息  
    -

# 并发编程  
- 多任务编程  
    - 特点:充分利用计算机CPU的多核资源,同时处理多个应用程序任务,以此提高程序的运行效率  
    - 实现方案:多进程,多线程  
- 进程 process 
    - 进程是程序在计算机中的一次运行  
        - 程序是一个可执行的文件,是静态的占用磁盘  
        - 进程是一个动态的过程描述,占用计算机运行资源,有一定的生命周期  
    - 进程产生过程  
        - 用户空间通过调用程序接口或者命令发起请求  
        - 操作系统接收用户请求开始创建进程  
        - 操作系统调配计算机资源确定进程状态  
        - 操作系统将创建的进程提供给用户使用  
    - 进程的基本概念  
        - cpu时间片:占用cpu内核的进程称其在时间片上,阻塞函数等待时就不在时间片上  
        - pcb进程控制块:在内存中存放进程基本信息,可用于系统查找识别进程 
        - pid进程ID:系统为每个进程分配的大于0不重复的整数标识;linux用ps -aux查看  
        - 父子进程:除系统初始进程外,系统中每一个进程都有唯一的父进程,有0个或多个子进程,便于进程的管理;用pstree查看
    - 进程的状态(三态+两态)  
        - 就绪态:进程具备执行条件,等待分配CPU资源  
        - 运行态:进程占用CPU时间片正在运行  
        - 等待态:进程暂停运行,让出CPU 
        - 新建态:开辟进程的过程  
        - 终止态:结束进程,释放资源  
        - 查看状态:ps -aux STAT列;S等待,I等待,R执行,Z僵尸,+前台,L多线程 
    - 进程的运行特征  
        - 多进程可以更充分使用计算机多核资源  
        - 进程之间的运行互不影响各自独立  
        - 每个进程拥有独立的空间各自使用自己空间资源  
- 基于os.fork()的进程-需在linux下  
    - pid = os.fork()
        - 功能:创建新的进程  
        - 返回值:整数  
            - 创建进程失败,返回一个负数  
            - 成功则在
                - 原有进程中返回新进程的PID(进程ID)
                - 在新进程中返回0,子进程拷贝父进程环境从创建函数后开始执行  
        - 使用:可以根据父子进程的返回值不同,使用分支语句实现各自独立抢占资源执行  
        - 父子进程特点:
            - 子进程会复制进程全部内存空间,从fork下一句开始执行  
            - 父进程fork之前开辟的空间子进程同样拥有,父子进程对各自空间操作不会互相影响  
            - 父子进程各自独立运行,运行顺序不一定  
            - 利用父子进程fork返回值的区别,配合if分支结构让父子进程执行不同的内容基本是固定搭配  
            - 父子进程有各自特有特征,如PID,PCB命令集  
            - 以os.fork()为起点,已执行代码只处现执行结果,整个父进程的代码及命名空间复制 
            - 再使用os.fork()平行创建子进程写在pid>0部分,向下创建子进程写在pid==0部分,不能直接在os.fork()下接os.fork()会循环  
- 进程函数  
    - os.getpid()  
        - 功能:获取一个进程的PID值  
        - 返回:当前进程的PID  
    - os.getppid()  
        - 功能:获取父进程的PID  
        - 返回:当前进程的父进程的PID  
    - os._exit(status)  
        - 功能:结束一个进程  
        - 参数:进程的终止状态码,整数,一般约定0为正常退出  
    - sys.exit([status])  
        - 功能:退出进程  
        - 参数:整数表示退出状态码,字符串表示退出时打印的内容
- 孤儿进程  
    - 父进程先于子进程退出,此时系统指定进程统一管理,子进程退出会自动处理
    - 基本不影响内存空间  
- 僵尸进程  
    - 子进程先于父进程退出,但父进程又没有处理子进程的退出状态,子进程会成为僵尸进程  
    - 子进程在驻留内存  
    - 避免产生僵尸的方法:  
        -  在父进程中加入 pid , status = os.wait() 
            - 功能:在父进程中阻塞等待处理子进程退出   
            - 返回值: pid 退出的子进程编号;status 退出的子进程状态码*256,也可使用os.WEXITSTATUS(status)得到子进程的状态码  
            - 缺点:由于父进程有阻塞,难以体现多进程同时执行的好处  
            - 改进方法,在子进程下再创建一个子进程os.fork()其用于执行,然后退出子进程,返回给父进程解除其阻塞,下级子进程变成孤儿进程由系统接管  
        - 在创建子进程前加入 import signal;signal.signal(signal.SIGCHLD,signal.SIG_IGN)  
            - 功能:让系统来处理子进程的退出  
            - 原理:子进程退出时会发送信号给父进程,如父进程忽略此信号,系统会自动处理子进程的退出  
            - 特点:非阻塞,不影响父进程的运行  
- 从聊天室看程序  
    - 确定需求(工作流程)  
    - 考量可能的技术应用(概要设计,技术补充)
    - 代码结构,功能模块划分  
    - 代码编写(客户端服务端分别做什么,避免随意流,先改逻辑,再改代码)  
    - 功能测试(一个功能完成就测试)  
    - 代码重构(细节改良完善)
- multiprocessing 模块创建进程  
    - 流程特点:
        - 将需要的子进程执行的事件封装为函数  
        - 通过模块的Process类创建进程对象,关联函数  
        - 可以通过进程对象设置进程信息及属性  
        - 通过进程对象调用start()启动进程  
        - 通过进程对象调用join()回收进程 
        - 进程个数与CPU的核数相关,是I/O型还是计算型,进程也需系统资源来维护  
        - 在windows下运行永远把实际执行功能的代码加入到带保护的区域中main 
    - 父子进程特点:
        - 父进程多用于创建子进程,回收子进程,具体的事件由子进程完成 
        - 父进程运行模块其余执行内容,可以一父多子,并使用容器存储进程及状态  
        - 子进程无法使用标准输入,实际python是后端程序,本身交互就少  
        - 子进程复制父进程空间代码段,globals副本以start()为界  
        - 父子进程运行互不影响  
        - 子进程只运行target绑定的函数  
    - Process()  
        - 功能:创建进程对象  
        - 参数:
            - target:绑定要执行的目标函数  
            - args元组:用于给target函数位置传参  
            - kwargs字典:用于给target函数键值传参
            - 复合传参:先位置(,)再关键字{k:v}  
        - 与fork()的等价:
            - fid = os.fork()
                - if fid == 0:
                    - taget_fun()
                - else:
                    - os.wait()
    - process_object.start()  
        - 功能:启动进程  
        - 备注:
            - 启动进程此时target绑定的函数开始执行  
            - 此函数作为子进程唯一执行内容  
            - 此时进程真正创建 
    - 在其间可以运行父进程
    - process_object.join([timeout]) 
        - 功能:阻塞等待回收进程  
        - 参数:
            - timeout:超时时间,默认是一直等到函数执行完毕 
    - process_object属性  
        - p.name 进程名称,可以Process(name=)中设置  
        - p.pid 对应子进程PID号,需p.start()已启动进程  
        - p.is_alive() 查看进程是否在生命周期内 
        - p.daemon = True ,在p.start()前设置,子进程将随着父进程的结束而结束,不会与p.join()同时设置 
    - 通过继承Process创建子类  
        - 使用super().\_\_init__()继承Process的属性  
        - 使用重写run()接口方法,让start()执行他  
    - pool进程池  
        - 通过创建一定数量的进程来处理事件  
        - 事件处理完进程并不立即退出 
        - 直到事件全部处理完毕统一销  
        - 增加进程的重复利用  
    - Pool(processes)  
        - 功能:创建进程池对象  
        - 参数:processes 指定进程数量,默认系统自动判定 
        - pool的实例化也需放在if_main下,可能此时进程就已启动
        - pool.apply_async(func,args,kwds)  
            - 功能:使用进程池执行func事件  
            - 参数:func 事件函数;args元组 给func按位置传参;kwds字典 给func按照键值传参  
        - pool.colse()  
            - 功能:关闭进程池,不再新加入进程池 
        - pool.join()  
            - 功能:回收进程池中进程,可以先用pool.colse()  
    - 进程间通信 IPC  
        - 进程间空间独立,资源不共享  
        - 进程间传递需要特定的手段进行数据通信  
        - 进程间通信方式:管道,消息队列,共享内存,信号,信号量,套接字  
        - 数据通信对文件等I/O操作的影响,若是在主进程创建的文件对象,各子进程获取时用是同一个文件描述符会相互影响,而各子进程对同一文件创建对象则相互独立
    - 管道通信 PIPE  
        - 原理:内存中开辟管道空间,生成管道操作对象,多个进程使用同一管道进行读写,实现了进程间通信  
        - fd1,fd2 = Pipe(duplex=True)
            - 功能:创建管道  
            - 参数:duplex为False表示单向,文件表示符fd1只读,fd2只写  
            - 返回值:表示管道两端的读写对象  
            - 使用:管道对象需在父进程中创建,在子进程中获取  
        - fd.recv()  
            - 返回值:从管道获取内容,需可读  
        - fd.send(data) 
            - 功能:向管道写入内容  
            - 参数:data要写入的数据,不强调是否为二进制  
    - 消息队列 Queue  
        - 原理:在内存中建立队列空间,进程通过队列将消息存入,或从队列取出,完成进程间通讯  
        - q = Queue(maxsize=0)
            - 参数:maxsize=最多存放消息个数  
            - 返回:队列对象 
            - 使用:数据先进先出,可用作请求与响应不同步的情况,在win下需作为参数传入进程 
        - q.put(data[,block,timeout])  
            - 功能:向队列存入(写)消息 
            - 参数:data要存入的数据;block设置是否阻塞,Flase为非阻塞;timeout超时检测(秒)  
        - q.get([block,timeout])
            - 参数:同put
            - 返回:从队列取出(读)消息data
        - q.full()队列是否为满  
        - q.empty()队列是否为空  
        - q.qsize()获取队列消息个数  
        - q.close()关闭队列 
    - 共享内存 
        - 原理:在内存中开辟一块空间,进程在其首地址进行读写,每次写入会覆盖之前内容,其交互效率较高   
        - obj = Value(ctype,data) 
            - 返回:共享内存对象  
            - 参数:ctype共享类型("i"|"f"|"c")同struct模块与c的套接字交互;data初始数据  
            - 应用:通过obj.value属性进行查看及赋值写入  
        - obj = Array(ctype,data)  
            - 返回:一个内存空间容器  
            - 参数:ctype同Value;data可以是一个结构或用int表示同类型数据的个数  
            - 应用:字节串可以通过obj.value属性一次显示 
    - 信号量 信号灯集Semaphore 
        - 原理: 给定一个正整数,多个进程可操作此数量的增减,并根据数量值决定应用的执行,同限流门票 
        - sem = Semaphore(num)  
            - 返回:信号量对象  
            - 参数:信号量初始值 
            - 属性:
                - sem.acquire() 将信号量减1,当信号量为0时阻塞  
                - sem.release() 将信号量加1  
                - sem.get_value() 获取当前信号量 

# 线程  
- 什么是线程:
    - 轻量级进程  
    - 利用多核进行多任务编程的方式  
    - 是系统分配内核的最小单元  
    - 可理解为进程的分支任务,操作系统按进程分配系统资源(内存寄存器CPU内核等),线程对系统资源再分配  
- 线程的特征:  
    - 一个进程可以多线程  
    - 线程也是一个运行行为,消耗系统资源  
    - 一个进程中的所有线程共享这个进程的资源  
    - 多个线程之间的运行互不影响各自运行  
    - 线程的创建和销资源远小于进程  
    - 各个线程也有自己的ID等特征  
    - 与进程的区别:
        - 分支线程的PID与主线程相同  
        - 分支线程使用与主线程使用同一命名空间,线程间通信就是使用其全局变量 
- threding 模块
    - Thread 类  
        - 创建:t = Thread(target,args,kwargs)  
            - 返回:线程对象  
            - 参数:同进程  
        - t.start()  
        - t.join([timeout])  
            - 功能:回收线程对象  
            - 参数:timeout超n秒回收 
        - t的属性
            - t.name 线程名称
                - t.setName() 设置线程名称 
                - t.getName() 获取线程名称  
            - t.is_alive() 线程在生命周期里吗  
            - t.daemon 设置主线程和分支线程的退出关系,在t.start()前设置,不与t.jion()同时应用  
                - t.setDaemon() 设置daemon属性  
                - t.isDaemon() 查看daemon属性  
                - daemon 默认为Flase,设为True时主线程退出分支线程退出 
    - 自定义MyThread类  
        - 思路:  
            - 继承于Thread类  
            - 重写\_\_init__方法添加自已的属性
                - 使用super()加载父类属性  
            - 重写run()方法
                - 对象执行start()会调用run()方法  
                - 通过self.target(\*self.args,self,**kwargs)可实现目标函数的调用  
    - 共享资源  
        - 多个进程或线程都可以操作的资源  
        - 通过同步互斥机制协调操作顺序  
            - 同步:是一种协作关系,如发(send)收(recv阻塞,非空时激活)  
            - 互斥:是一种制约关系,抢占资源后加锁,结束后解锁  
    - Event类  
        - 创建:e=Event()->e.is_set()为Flase  
        - e.wait([timeout])  
            - 返回:当e未被设置返回False,否则True  
            - 参数:timeout阻塞时间  
            - 应用:可在主线程设置让其等待,分支线程通过e.set()解除等待
        - e.set()  
            - 功能:设置e,使e.wait()结束阻塞  
        - e.clear()
            - 功能:使e回到未被e.set()设置状态  
        - e.is_set()  
            - 返回:e被设置为True  
    - Lock类  
        - 创建:l=Lock()
        - l.acquire()  
            - 上锁并返回True,若已上锁则会阻塞等待  
        - l.release()  
            - 解锁,若未上锁则报RuntimeError  
        - whit l:
            - 上锁,代码块结束自动解锁  
    - 死锁  
        - 死锁是指两个或两个以上的线程在执行过程中,由于竞争资源或由于彼此通信而造成的一种阻塞现象  
        - 原因是:
            - 当前线程拥有其他线程需要的资源  
            - 当前线程等待其他线程已拥有的资源  
            - 都不放弃自己拥有的资源  
    - python线程的GIL(全局解释器锁)  
        - 由于设计中加入了解释器锁
            - 导致解释器同一时刻只能执行一个线程,大大降低了线程的执行效率  
            - 但执行多阻塞高延迟I/O时(遇阻塞线程会让出解释器),可以提升效率,如网络访问  
# 网络并发  
- 网络模型  
    - 循环服务器模型  
        - 原理:循环接收客户端请求,处理请示.同一时刻只处理一个请求,完毕后处理下一个  
        - 优点:实现简单,占用资源少 
        - 缺点:无法同时处理多个客户端请求  
        - 适用:任务很快完成,客户端无需长期占用  
        - 实现:udp比tcp更适合  
    - 多进程/多线程网络并发模型  
        - 原理:每当一个客户端连接服务器,创建一个新的进程/线程为该客户端服务,客户端退出时再销此进程/线程  
        - 优点:能满足多个客户端长期占用服务  
        - 缺点:资源消耗较大  
        - 适用:客户端同时连接量较少,需要处理行为复杂  
# IO并发模型  
- 基础:
    - 利用IO多路复用异路IO等技术,同时处理多个客户端IO请求  
    - 优点:资源消耗少,能同时高效处理多个IO行为  
    - 缺点:只能处理并发产生的IO事件,无法处理CPU计算  
    - 适用:HTTP请求,网络传输等IO行为  
- IO并发分类  
    - 阻塞IO  
        - 定义:在执行IO操作中,如果执行条件不满足则阻塞,阻塞IO是IO的默认形态  
        - 效率:阻塞IO是效率最低的一种IO,但逻辑简单  
        - 情况:  
            - 因为某种执行条件没有满足造成的函数阻塞:accept,imput,recv,sleep  
            - 处理IO的时间较长产生的阻塞状况:网络传输,大文件读写  
    - 非阻塞IO  
        - 定义:通过修改IO属性行为,使原本阻塞的IO变为非阻塞的状态  
        - 设置套接字为非阻塞IO  
            - 定义: sockfd.setblocking(bool)  
            - 功能: 设置套接字为非阻塞IO  
            - 参数: 设为False则套接字IO变成非阻塞  
        - 设置超时检测  
            - 定义: sockfd.settimeout(sec)  
            - 功能:设置一个最长阻塞时间,超过该时间后则不再阻塞等待,不与非阻塞同用  
            - 参数: sec为等待的移数  
    - IO多路复用  
        - 定义: 利用内核同时监控多个IO事件,当哪个IO事件准备就绪(指点应用层已达提交内核处理的状态),就执行哪个IO事件,以此形成同时处理多个IO的行为,避免一个IO阻塞造成其他IO均无法执行 
        - 模块: select  
        - select方法  
            - 定义: rs,ws,xs = select(rlist,wlist,xlist[,timeout])  
            - 功能: 提交内核监控IO事件,阻塞等待IO发生,有一个或多个就绪返回列表为元素的三元组  
            - 参数:   
                - rlist列表,用于存放关注等待发生的IO事件,如获取通知的读recv    
                - wlist列表,用于存放关注的要主动处理的IO事件,如提交处理的send  
                - xlist列表,用于存放关注的出现异常要处理的IO,如except,在linux下无效  
                - 一个要关注的IO可以同时放在多个列表,如套接字放在rlist,wlist中  
                - timeout 设置超时时间解锁,无则阻塞  
            - 返回值:  
                - rs列表,rlist中准备就绪的IO  
                - ws列表,wlist中准备就绪的IO  
                - xs列表,xlist中准备就结的IO  
        - poll方法  
            - 定义: p=select.poll()  
                - 功能:返回poll对象  
            - fdmap = {obj.fileno():obj...} ;fdmap[obj.fileno()]=obj 
                - 功能:创建并维护文件描述符字典,便于从fileno查找到对象
            - p.register(fd,event)  
                - 功能:注册关注的IO事件  
                - 参数:fd要关注的IO对象或IO对象的文件描述符;event常用类型(1PLOOIN:读IO事件rlist,4POLLOUT:写IO事件wlist,8POLLERR:异常IOxlist,16POLLHUP:断开连接)  
                - eg:p.register(sockfd,POLLIN|POLLERR) 因是按二进制1,10,100,1000为POLL常量,故可以用或表示多种类型  
            - p.unregister(fd)  
                - 功能:取消对IO的关注  
            - events = p.poll()  
                - 功能:阻塞等待监控的IO事件发生  
                - 返回:发生IO的[(fileno,event),...],元组为两个整数,通过字典解析  
        - epoll方法  
            - 定义:ep = select.epoll()  
            - 其他操作基本同poll,但epoll有新的常量如EPOLLET用于边缘触发,epoll不用应用层轮询效率更高

# 位运算  
- 将整数换成二进制,并对其各位进行的运算,1为真,0为假  
- 种类:  
    - 与& 遇0则0,可用于判断是否具备此属性  
    - 或| 遇1则1,可用于增补属性  
    - 异或^ 相同为0,不同为1,等同或减与  
    - 左移<< 向左移位,低位补0,同乘*2N位  
    - 右移>> 向右移位,低位去掉,同整除//2N位  
- 综合属性应用 
    - 将属性(高大,技术,有钱,激情,幽默)综合赋值=15  
    - 增加属性高大 object.attr = object.attr|高大  
    - 属性判断有钱 object.attr&有钱-->True|False 

# 协程
- 定义:也称纤程 微经程,允许在不同入口点不同位置暂停或开始的程序,即可暂停执行的函数  
- 原理:记录一个函数的上下文,协程调度切换时会记录的上下文保存,在切换回来时进行调取,恢复原有的执行内容,以便从上一次执行位置继续执行  
- 优点:
    - 协程完成多任务占用计算资源很少  
    - 协程的多任务切换在应用层完成,切换开销少  
    - 协程为单线程程序,无需进行共享资源同步互斥资源  
- 缺点:
    - 协程的本质是一个单线程,无法利用计算机多核资源  
    - 模块asyncio 对跳转的支持还仅限于其内部函数,生态支持不够  
    - 第三方模块greenlet gevent等扩展了支持  

# 正则表达式 
- 定义: 由一系列字符和特殊符号构成的字符串,用以描述一定的字符串规划,来表达某类特定的字符串,进现匹配  
- 元字符:  
    - 普通字符   
        - 匹配规则:每个普通字符匹配对应的字符  
        - 如"abc" 匹配abc,是以整体为规则的描述,支持汉字匹配,# -*- coding:utf-8 -*-
    - 或关系 |  
        - 匹配规则:匹配|两侧任意的正则表达式  
        - "ab|c" 匹配ab或c任意一个,不要加空格,其也是字符  
    - 任意单字符 .  
        - 匹配规则:匹配除换行外的任意一个字符  
        - "a.b" 匹配acb等,标点也是字符  
    - 单个字符集 []  
        - 匹配规则:匹配集中的任意一个字符,可使用区间表示,集中是或关系  
        - [0-9]数字,[a-z]小写字母,[A-Z]大写字母,混合书写时零散字符靠前区间表达靠后  
    - 单个字符取反集[^]  
        - 匹配规则:匹配不在集中的任意一个字符,可使用区间表示  
        - [^0-9]非数字,[^a-z]非小写字母,[^A-Z]非大写字母,混合书写时零散字符靠前区间表达靠后  
    - 开始位置 
        - 元字符 ^  \A
        - 匹配规则:匹配目标字符串的开头位置  
        - \^[0-9]  \A\d 以数字开头   
    - 结束位置 
        - 元字符 $ \Z  
        - 匹配规则:匹配目标字符串的结束位置  
        - [0-9]$ \Z\d 以数字结束,\n不参与匹配,  
        - ^$必然出现在正则表达式的开头和结尾处,如果两者同时出现,则中间部分必须匹配整个目标字符串的全部内容  
    - 前字符重复 
        - 0次或多次 元字符 *  
            - 匹配规则:*前面的一个字符出现0次或多次  
            - 'wo*'指w,wo,woo,wooo...,把o*作为一个整体  
        - 1次或多次 元字符 +  
            - 匹配规则:*前面的一个字符出现1次或多次  
            - 'wo+'指wo,woo,wooo... ,把o+作为一个整体   
        - 0次或1次 元字符 ?  
            - 匹配规则:?前面的一个字符出现0次或1次  
            - 'wo?'指w,wo ,把o?作为一个整体   
        - n次  元字符{n}  
            - 匹配规则:{n}前面的一个字符出现n次  
            - 'wo{3}'指wooo ,把o{n}作为一个整体  
        -  m-n次  元字符{m,n}  
            - 匹配规则:{m,n}前面的一个字符出现最少m次,最多n次  
            - 'wo{1,3}'指wo,woo,wooo ,把o{m,n}作为一个整体,包含m和n   
        - 模式选择  
            - 贪婪模式,默认情况下重复的元字符*+?{m,n}总是尽可能多的向后匹配内容  
            - 非贪婪模式,在重复的元字符*+?{m,n}后加?,将惰性计算达到条件就停  
        - 分组  
            - 以(...)建立子组,以作为内部操作对象,便于使用重复的元字符*+?{m,n}{n},但不适合使用findall(),可用search().group()返回  
            - 捕获组(?p<name>pattern)-->group(<name>)可以给正则表达式的子组起一个名字,表达该子组的意义,同变量赋值  
            - 注:一个正则表达式可以多个子组,子组可以嵌套但不要重叠或复杂的结构,子组序号从外到内从左到右计数  
    - 数字字符  
        - 元字符 \d 
            - 匹配任意数字,同[0-9] 
        - 元字符 \D  
            - 匹配任意非数字,同[^0-9]  
    - 标识符  
        - 标识符: 数字,字母,下划线,汉字,其他语言
        - 元字符 \w 
            - 匹配任意标识符 
        - 元字符 \W  
            - 匹配任意非标识符,如#,. 
    - 标识符边界  
        - 标识符边界:指数字,字母,下划线,汉字,其他语言与其他字符的交界位置  
        - 元字符 r"\b" 
            - 匹配标识符边界,记得使用r,不然转义了 
        - 元字符 \B  
            - 匹配任意非标识符边界
    - 空字符  
        - 空字符:空格,\r\n\t\v\f
        - 元字符\s
            - 匹配任意空字符  
        - 元字符\S
            - 匹配任意非空字符  
    - 匹配字符: .[...][^...]\d\D\w\W\s\S  
    - 重复: *+?{n}{m,n}  
    - 位置: ^$\A\Z\b\B  
    - 其他: |()\  
- 特殊字符匹配  
    - 特殊字符: .*+?^$[](){}|\  
    - 使用在特殊字符前加\进行转义,匹配特殊字符,但需注意字符串本身传给python时进行了转义,所以有时需出现\\\b,\b有语义是退格  
    - 在正则表达式前加r表示原生字符串,避免出现多重转义  
    - 不要写在[0-9^.]字符集的开头 
- re模块  
    - 定义:regex = compile(pattern,flags=0)  
        - 返回:正则表达式对象  
        - 参数:pattern正则表达式;flags功能标志位  
        - 显示:re.compile('...')
        - regex:对象也可调用多个与类函数的同名函数,但不用再传入正则 
        - regex属性:
            - regex.pattern 正则表达式  
            - regex.groups 子组数量  
            - regex.groupindex 捕获已命名组名为键,与序号为值的字典()
    - 通用参数
        - flags:功能标志位re.下的常量,多个标志可以通过按位或"|"连接    
            - A,ASCII 元字符只能匹配ASCII码  
            - S,DOTALL 使.可以匹配含换行符的所有内容 
            - I,IGNORECASE 不区分大小写  
            - L,LOCALE
            - M,MULTILINE 使^$可以匹配每一行的开头和结尾  
            - T,TEMPLATE  
            - U,UNICODE  
            - X,VERBOSE 需匹配含有注释的正则表达式适用,把正则表达式里#前的空格及#后的内容当成注释不参与匹配 
        - pattern:正则表达式  
        - string:目标字符串  
        - pos:目标字符串的开始位  
        - endpos:目标字符串的结束位  
    - re.findall(prttern,string,flags=0)  
        - 功能:根据正则匹配目标字符串内容  
        - 返回:符合正则的列表,如果正则有子组则只能获得子组对应的内容,两个以上子组则使用元组作为元素返回 
    - regex.findall(string,pos,endpos)  
        - 返回:同re.findall,但可加开始pos(含)和结束endpos(不含)限定string[pos,endpos]  
    - re.split(prttern,string,flags=0)  
        - 功能:根据正则匹配到的内容为分割符,切割目标字符串  
    - re.sub(prttern,replace,string,count,flags=0)  
        - 功能:使用一个字符串replace替换正则匹配到的内容最多换count次(默认是全部)  
        - 返回:替换后的字符串  
    - re.subn(prttern,replace,string,count,flags=0) 
        - 功能同sub  
        - 返回:一个替换后的字符串和实际替换次数的元组  
        - 功能:根据正则匹配目标字符串内容  
        - 返回:符合正则的列表,如果正则有子组则只能获得子组对应的内容,两个以上子组则使用元组作为元素返回 
    - re.finditer(prttern,string,flags=0)
        - 功能:根据正则匹配目标字符串内容  
        - 返回:一个match_object对象的迭代器,未找到对象也返回一个为空的迭代器  
    - re.fullmatch(prttern,string,flags=0)  
        - 功能：完全匹配某个目标字符串内容同r"^pattern$"  
        - 返回:一个match_object对象,未找到返回None  
        - 如果不确定找到,可以使用if re.fullmatch():检效是否返回None  
    - re.match(prttern,string,flags=0)  
        - 功能：从开始部分匹配某个目标字符串内容同r"^pattern"  
        - 返回:一个match_object对象,未找到返回None  
    - re.search(prttern,string,flags=0)  
        - 功能：匹配目标字符串第一个符合内容  
        - 返回:一个match_object对象,未找到返回None  
    - match_object对象 
        - 一个match_object对象只对应一个匹配内容  
        - 属性:
            - pos 匹配的目标字符串开始位置  
            - endpos 匹配的目标字符串结束位置的下一个  
            - re 正则表达式  
            - string 目标字符串,是全部不仅是匹配部分  
            - lastgroup 最后一组的名称,未命名为None  
            - lastindex 最后一组的序号  
        - 方法:
            - span() 获取匹配内容的起止位置  
            - start() 获取匹配内容的开始位置  
            - end() 获取匹配内容的结束位置  
            - groupdict() 获取捕获命名组名字典,以组名为键,对应内容为值  
            - groups() 获取子组对应内容  
            - group(n=0) 
                - 功能:获取match对象匹配内容  
                - 返回:匹配字符串  
                - 参数:0为获取整个match对象内容,可以传子组索引或组名,可以传入多个参数匹配内容打包成元组返回  